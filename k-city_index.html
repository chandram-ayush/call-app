<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>K-City Stable</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root { --primary: #00f2ff; --danger: #ff0055; --bg: #0a0a0a; --glass: rgba(255, 255, 255, 0.1); }
        body { background: var(--bg); color: #fff; font-family: 'Inter', sans-serif; margin: 0; height: 100dvh; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        
        h1 { font-weight: 800; letter-spacing: -1px; margin-bottom: 5px; font-size: 2rem; background: linear-gradient(to right, #fff, #888); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .btn-grid { display: grid; gap: 15px; width: 90%; max-width: 320px; margin-top: 30px; }
        
        .btn { border: none; padding: 18px; border-radius: 12px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: 0.2s; text-transform: uppercase; letter-spacing: 1px; display: flex; align-items: center; justify-content: center; gap: 10px; }
        .btn:active { transform: scale(0.96); }
        .btn-cam { background: rgba(0, 242, 255, 0.1); color: var(--primary); border: 1px solid rgba(0, 242, 255, 0.3); }
        .btn-watch { background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.2); }
        .btn-end { background: var(--danger); color: white; padding: 12px 30px; border-radius: 30px; box-shadow: 0 5px 20px rgba(255, 0, 85, 0.4); pointer-events: auto; }

        .floating-controls { position: fixed; bottom: 30px; left: 0; width: 100%; display: flex; justify-content: center; z-index: 200; pointer-events: none; }
        
        #status-overlay { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.85); padding: 25px; border-radius: 15px;
            text-align: center; z-index: 140; backdrop-filter: blur(10px); border: 1px solid #333;
            width: 80%; max-width: 300px;
        }
        .status-text { color: #00f2ff; font-family: monospace; font-size: 1.1rem; margin-bottom: 5px; }
        .status-sub { color: #aaa; font-size: 0.8rem; }

        .vid-container { position: relative; width: 100%; height: 100%; background: #000; }
        video { width: 100%; height: 100%; object-fit: contain; background: black; }
        
        #stealth { position: fixed; inset: 0; background: #000; z-index: 999; display: flex; align-items: center; justify-content: center; cursor: pointer; }
        
        /* Pulse Animation for Connection Health */
        .ping-dot { position: absolute; top: 10px; right: 10px; width: 8px; height: 8px; border-radius: 50%; background: #00ff00; opacity: 0; transition: opacity 0.2s; }
        .ping-active { opacity: 1; }

        .hidden { display: none !important; }
        .fade-in { animation: fadeIn 0.5s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

    <div id="home" class="fade-in">
        <h1>K-CITY LINK</h1>
        <p>System Ready</p>
        <div id="server-indicator" style="font-size: 10px; color: #555; margin-top: 10px;">Connecting...</div>
        <div class="btn-grid">
            <button class="btn btn-cam" onclick="startBroadcasterMode()"><span>üì∑</span> I am Camera</button>
            <button class="btn btn-watch" onclick="startViewerMode()"><span>üëÄ</span> I am Viewer</button>
        </div>
    </div>

    <div id="standby" class="hidden fade-in" style="text-align: center;">
        <div class="ping-dot" id="cam-ping"></div>
        <div style="font-size: 3rem; margin-bottom: 20px;">üõ°Ô∏è</div>
        <h1>SYSTEM ARMED</h1>
        <p>Standby Mode Active</p>
        <p id="standby-msg" style="margin-top: 30px; font-size: 0.8rem; opacity: 0.5;">
            Keep this tab open.<br>Do not minimize.
        </p>
    </div>

    <div id="viewer" class="hidden vid-container">
        <div id="status-overlay">
            <div class="status-text" id="conn-state">Initializing...</div>
            <div class="status-sub" id="conn-hint">Connecting to Server</div>
        </div>
        <video id="remoteVideo" autoplay playsinline></video>
        <div id="play-overlay" class="hidden" style="position:absolute; inset:0; background:rgba(0,0,0,0.8); display:flex; justify-content:center; align-items:center; z-index:150;">
            <button class="btn btn-watch" onclick="forcePlay()">‚ñ∂ Play Video</button>
        </div>
        <div class="floating-controls">
            <button class="btn btn-end" onclick="endCall()">End Call</button>
        </div>
    </div>

    <video id="localVideo" muted playsinline autoplay style="display: none;"></video>
    <div id="stealth" class="hidden" ondblclick="toggleStealth()"></div>

    <script>
        const socket = io({
            reconnection: true,
            reconnectionAttempts: Infinity,
            reconnectionDelay: 1000
        });

        // STUN Servers (Google + Open Source)
        const config = { 
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ] 
        };
        
        let localStream = null;
        let wakeLock = null;
        let heartbeatInterval = null;
        const peerConnections = {}; 
        let iceCandidatesQueue = [];

        // --- GLOBAL HELPERS ---
        function updateState(state, hint="") {
            document.getElementById('conn-state').innerText = state;
            document.getElementById('conn-hint').innerText = hint;
            if (state === 'Connected') {
                setTimeout(() => document.getElementById('status-overlay').classList.add('hidden'), 500);
            } else {
                document.getElementById('status-overlay').classList.remove('hidden');
            }
        }

        socket.on('connect', () => {
            document.getElementById('server-indicator').innerText = "‚óè Server Connected";
            document.getElementById('server-indicator').style.color = "#00ff00";
            // Start Heartbeat to keep mobile connection alive
            if(heartbeatInterval) clearInterval(heartbeatInterval);
            heartbeatInterval = setInterval(() => {
                socket.emit('heartbeat');
                // Visual feedback for heartbeat
                const dot = document.getElementById('cam-ping');
                dot.classList.add('ping-active');
                setTimeout(() => dot.classList.remove('ping-active'), 200);
            }, 2000);
        });

        socket.on('disconnect', () => {
            document.getElementById('server-indicator').innerText = "‚óã Disconnected (Reconnecting...)";
            document.getElementById('server-indicator').style.color = "#ff0000";
            if(document.getElementById('standby').classList.contains('hidden') === false) {
                document.getElementById('standby-msg').innerText = "‚ö†Ô∏è LOST CONNECTION! RECONNECTING...";
                document.getElementById('standby-msg').style.color = "red";
            }
        });

        // --- BROADCASTER ---
        async function startBroadcasterMode() {
            document.getElementById('home').classList.add('hidden');
            document.getElementById('standby').classList.remove('hidden');
            try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
            
            // Register immediately
            socket.emit('broadcaster');

            // Force permission warmup
            try { const t = await navigator.mediaDevices.getUserMedia({video:true}); t.getTracks().forEach(tr => tr.stop()); } 
            catch(e) { alert("Please Allow Camera Permissions!"); }
        }

        socket.on('watcher', async (id) => {
            if (!localStream) {
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: true });
                    document.getElementById('localVideo').srcObject = localStream;
                    document.getElementById('stealth').classList.remove('hidden'); 
                } catch(e) { alert("Cam Start Failed: " + e.message); return; }
            }

            const peer = new RTCPeerConnection(config);
            peerConnections[id] = peer;
            localStream.getTracks().forEach(track => peer.addTrack(track, localStream));
            peer.onicecandidate = e => { if(e.candidate) socket.emit('candidate', id, e.candidate); };
            const offer = await peer.createOffer();
            await peer.setLocalDescription(offer);
            socket.emit('offer', id, peer.localDescription);
        });

        socket.on('answer', (id, desc) => { if(peerConnections[id]) peerConnections[id].setRemoteDescription(desc); });
        socket.on('candidate', (id, cand) => { if(peerConnections[id]) peerConnections[id].addIceCandidate(new RTCIceCandidate(cand)); });
        
        socket.on('disconnectPeer', (id) => {
            if(peerConnections[id]) { peerConnections[id].close(); delete peerConnections[id]; }
            if (Object.keys(peerConnections).length === 0) {
                if(localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
                document.getElementById('stealth').classList.add('hidden');
            }
        });

        function toggleStealth() { document.getElementById('stealth').classList.add('hidden'); }

        // --- VIEWER ---
        let viewerPeer = null;

        function startViewerMode() {
            document.getElementById('home').classList.add('hidden');
            document.getElementById('viewer').classList.remove('hidden');
            updateState("Checking Camera Status...");
            
            // Ask server if camera is actually online first
            socket.emit('check_status');
        }

        socket.on('status_response', (isOnline) => {
            if (isOnline) {
                updateState("Requesting Video...");
                socket.emit('watcher');
                
                // Timeout Warning
                setTimeout(() => {
                    if(!viewerPeer || viewerPeer.connectionState !== 'connected') {
                        updateState("Slow Connection", "Phone might be asleep. Wake it up.");
                    }
                }, 8000);
            } else {
                updateState("Camera Offline", "Please open app on Phone first");
            }
        });

        socket.on('offer', async (id, desc) => {
            updateState("Negotiating...", "Establishing P2P Link");
            viewerPeer = new RTCPeerConnection(config);
            
            while (iceCandidatesQueue.length > 0) {
                viewerPeer.addIceCandidate(new RTCIceCandidate(iceCandidatesQueue.shift()));
            }

            viewerPeer.onconnectionstatechange = () => {
                const state = viewerPeer.connectionState;
                if (state === 'connected') updateState("Connected");
                if (state === 'failed') updateState("Connection Failed", "Try same WiFi");
                if (state === 'disconnected') updateState("Disconnected");
            };

            viewerPeer.ontrack = e => {
                const vid = document.getElementById('remoteVideo');
                if (vid.srcObject !== e.streams[0]) {
                    vid.srcObject = e.streams[0];
                    vid.play().then(() => updateState("Connected")).catch(e => {
                        document.getElementById('play-overlay').classList.remove('hidden');
                        updateState("Action Required", "Click Play Button");
                    });
                }
            };

            viewerPeer.onicecandidate = e => { if(e.candidate) socket.emit('candidate', id, e.candidate); };
            await viewerPeer.setRemoteDescription(desc);
            const answer = await viewerPeer.createAnswer();
            await viewerPeer.setLocalDescription(answer);
            socket.emit('answer', id, viewerPeer.localDescription);
        });

        socket.on('candidate', (id, cand) => {
            if (viewerPeer && viewerPeer.remoteDescription) {
                viewerPeer.addIceCandidate(new RTCIceCandidate(cand));
            } else {
                iceCandidatesQueue.push(cand);
            }
        });

        function forcePlay() {
            document.getElementById('remoteVideo').play();
            document.getElementById('play-overlay').classList.add('hidden');
            updateState("Connected");
        }

        socket.on('broadcaster_left', () => { alert("Camera went offline"); location.reload(); });
        function endCall() { socket.disconnect(); location.reload(); }
    </script>
</body>
</html>