<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>K-City Pro</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root { --primary: #00f2ff; --danger: #ff0055; --bg: #0a0a0a; --glass: rgba(255, 255, 255, 0.1); }
        body { background: var(--bg); color: #fff; font-family: 'Inter', sans-serif; margin: 0; height: 100dvh; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        
        /* UI Elements */
        h1 { font-weight: 800; letter-spacing: -1px; margin-bottom: 5px; font-size: 2rem; background: linear-gradient(to right, #fff, #888); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .btn-grid { display: grid; gap: 15px; width: 90%; max-width: 320px; margin-top: 30px; }
        
        .btn { border: none; padding: 18px; border-radius: 12px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: 0.2s; text-transform: uppercase; letter-spacing: 1px; display: flex; align-items: center; justify-content: center; gap: 10px; }
        .btn:active { transform: scale(0.96); }
        .btn-cam { background: rgba(0, 242, 255, 0.1); color: var(--primary); border: 1px solid rgba(0, 242, 255, 0.3); }
        .btn-watch { background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.2); }
        
        .floating-controls { position: fixed; bottom: 30px; left: 0; width: 100%; display: flex; justify-content: center; z-index: 200; pointer-events: none; }
        .btn-end { background: var(--danger); color: white; padding: 12px 30px; border-radius: 30px; box-shadow: 0 5px 20px rgba(255, 0, 85, 0.4); pointer-events: auto; }

        /* Overlays */
        #play-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 150; display: flex; align-items: center; justify-content: center; flex-direction: column; }
        
        #status-overlay { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.85); padding: 25px; border-radius: 15px;
            text-align: center; z-index: 140; backdrop-filter: blur(10px); border: 1px solid #333;
            width: 80%; max-width: 300px;
        }
        .status-text { color: #00f2ff; font-family: monospace; font-size: 1.1rem; margin-bottom: 5px; }
        .status-sub { color: #aaa; font-size: 0.8rem; }

        /* Video Area */
        .vid-container { position: relative; width: 100%; height: 100%; background: #000; }
        video { width: 100%; height: 100%; object-fit: contain; background: black; }
        
        .live-badge { position: absolute; top: 20px; left: 20px; z-index: 100; background: rgba(255, 0, 0, 0.8); color: white; padding: 5px 12px; border-radius: 4px; font-weight: bold; font-size: 0.8rem; display: flex; align-items: center; gap: 6px; }
        .live-dot { width: 8px; height: 8px; background: white; border-radius: 50%; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        #stealth { position: fixed; inset: 0; background: #000; z-index: 999; display: flex; align-items: center; justify-content: center; cursor: pointer; }
        #stealth span { color: #333; font-size: 1rem; animation: fadeOut 4s forwards; }
        @keyframes fadeOut { to { opacity: 0; } }

        .hidden { display: none !important; }
        .fade-in { animation: fadeIn 0.5s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

    <div id="home" class="fade-in">
        <h1>K-CITY LINK</h1>
        <p>System Ready</p>
        <div class="btn-grid">
            <button class="btn btn-cam" onclick="startBroadcasterMode()"><span>üì∑</span> I am Camera</button>
            <button class="btn btn-watch" onclick="startViewerMode()"><span>üëÄ</span> I am Viewer</button>
        </div>
    </div>

    <div id="standby" class="hidden fade-in" style="text-align: center;">
        <div style="font-size: 3rem; margin-bottom: 20px;">üõ°Ô∏è</div>
        <h1>SYSTEM ARMED</h1>
        <p>Standby Mode Active</p>
        <p style="margin-top: 30px; font-size: 0.8rem; opacity: 0.5;">Screen is Awake.<br>Camera OFF until viewer connects.</p>
    </div>

    <div id="viewer" class="hidden vid-container">
        <div class="live-badge"><div class="live-dot"></div><span id="view-count">0</span> Viewers</div>
        
        <div id="status-overlay">
            <div class="status-text" id="conn-state">Initializing...</div>
            <div class="status-sub" id="conn-hint">Connecting to Server</div>
        </div>

        <video id="remoteVideo" autoplay playsinline></video>

        <div id="play-overlay" class="hidden">
            <button class="btn btn-watch" onclick="forcePlay()">‚ñ∂ Click to Play Video</button>
        </div>

        <div class="floating-controls">
            <button class="btn btn-end" onclick="endCall()">Leave Stream</button>
        </div>
    </div>

    <video id="localVideo" muted playsinline autoplay style="display: none;"></video>

    <div id="stealth" class="hidden" ondblclick="toggleStealth()">
        <div class="live-badge" style="top: 50%; left: 50%; transform: translate(-50%, -50%); background: none;">
            <span id="stealth-count" style="color: #333; font-size: 2rem;">0</span>
        </div>
        <span style="position: absolute; bottom: 50px;">Recording Active. Double Tap to Wake.</span>
    </div>

    <script>
        const socket = io();
        
        // FIX: More STUN servers to increase connection success rate
        const config = { 
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ] 
        };
        
        let localStream = null;
        let wakeLock = null;
        const peerConnections = {}; 
        let iceCandidatesQueue = []; // FIX: Buffer for early candidates

        // --- UI HELPERS ---
        function updateState(state, hint="") {
            const el = document.getElementById('conn-state');
            const sub = document.getElementById('conn-hint');
            el.innerText = state;
            sub.innerText = hint;
            
            if (state === 'Connected') {
                setTimeout(() => document.getElementById('status-overlay').classList.add('hidden'), 500);
            } else {
                document.getElementById('status-overlay').classList.remove('hidden');
            }
        }

        socket.on('update_count', (count) => {
            document.getElementById('view-count').innerText = count;
            document.getElementById('stealth-count').innerText = count;
        });

        // --- BROADCASTER ---
        async function startBroadcasterMode() {
            document.getElementById('home').classList.add('hidden');
            document.getElementById('standby').classList.remove('hidden');
            try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
            socket.emit('broadcaster');
            try { const t = await navigator.mediaDevices.getUserMedia({video:true}); t.getTracks().forEach(tr => tr.stop()); } catch(e) { alert("Enable Camera Permissions!"); }
        }

        socket.on('watcher', async (id) => {
            if (!localStream) {
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: true });
                    document.getElementById('localVideo').srcObject = localStream;
                    document.getElementById('stealth').classList.remove('hidden'); 
                } catch(e) { alert("Cam Failed: " + e.message); return; }
            }

            const peer = new RTCPeerConnection(config);
            peerConnections[id] = peer;
            localStream.getTracks().forEach(track => peer.addTrack(track, localStream));
            peer.onicecandidate = e => { if(e.candidate) socket.emit('candidate', id, e.candidate); };
            
            const offer = await peer.createOffer();
            await peer.setLocalDescription(offer);
            socket.emit('offer', id, peer.localDescription);
        });

        socket.on('answer', (id, desc) => { if(peerConnections[id]) peerConnections[id].setRemoteDescription(desc); });
        socket.on('candidate', (id, cand) => { if(peerConnections[id]) peerConnections[id].addIceCandidate(new RTCIceCandidate(cand)); });
        
        socket.on('disconnectPeer', (id) => {
            if(peerConnections[id]) { peerConnections[id].close(); delete peerConnections[id]; }
            if (Object.keys(peerConnections).length === 0) {
                if(localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
                document.getElementById('stealth').classList.add('hidden');
            }
        });

        function toggleStealth() { document.getElementById('stealth').classList.add('hidden'); }

        // --- VIEWER ---
        let viewerPeer = null;

        function startViewerMode() {
            document.getElementById('home').classList.add('hidden');
            document.getElementById('viewer').classList.remove('hidden');
            updateState("Waiting...", "Searching for Camera...");
            socket.emit('watcher');

            // Timeout Warning
            setTimeout(() => {
                if(!viewerPeer || viewerPeer.connectionState !== 'connected') {
                    updateState("Slow Connection", "Check if Camera is online");
                }
            }, 8000);
        }

        socket.on('offer', async (id, desc) => {
            updateState("Negotiating...", "Found Camera. connecting...");
            viewerPeer = new RTCPeerConnection(config);
            
            // FIX: Process buffered candidates
            while (iceCandidatesQueue.length > 0) {
                const cand = iceCandidatesQueue.shift();
                viewerPeer.addIceCandidate(new RTCIceCandidate(cand));
            }

            viewerPeer.onconnectionstatechange = () => {
                const state = viewerPeer.connectionState;
                if (state === 'connected') updateState("Connected", "Live Stream Active");
                if (state === 'failed') updateState("Connection Failed", "Firewall blocking P2P. Use same WiFi.");
                if (state === 'disconnected') updateState("Disconnected", "Stream ended");
            };

            viewerPeer.ontrack = e => {
                const vid = document.getElementById('remoteVideo');
                if (vid.srcObject !== e.streams[0]) {
                    vid.srcObject = e.streams[0];
                    vid.play().then(() => updateState("Connected")).catch(e => {
                        document.getElementById('play-overlay').classList.remove('hidden');
                        updateState("Action Required", "Click Play Button");
                    });
                }
            };

            viewerPeer.onicecandidate = e => { if(e.candidate) socket.emit('candidate', id, e.candidate); };
            await viewerPeer.setRemoteDescription(desc);
            const answer = await viewerPeer.createAnswer();
            await viewerPeer.setLocalDescription(answer);
            socket.emit('answer', id, viewerPeer.localDescription);
        });

        // FIX: Candidate Buffering Logic
        socket.on('candidate', (id, cand) => {
            if (viewerPeer && viewerPeer.remoteDescription) {
                viewerPeer.addIceCandidate(new RTCIceCandidate(cand));
            } else {
                iceCandidatesQueue.push(cand);
            }
        });

        function forcePlay() {
            document.getElementById('remoteVideo').play();
            document.getElementById('play-overlay').classList.add('hidden');
            updateState("Connected");
        }

        socket.on('broadcaster_left', () => { alert("Broadcaster Offline"); location.reload(); });
        function endCall() { socket.disconnect(); location.reload(); }
    </script>
</body>
</html>